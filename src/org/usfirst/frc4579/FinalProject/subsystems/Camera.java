// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc4579.FinalProject.subsystems;

import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.camera.AxisCamera;
import edu.wpi.first.wpilibj.camera.AxisCameraException;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.image.BinaryImage;
import edu.wpi.first.wpilibj.image.ColorImage;
import edu.wpi.first.wpilibj.image.CriteriaCollection;
import edu.wpi.first.wpilibj.image.NIVision;
import edu.wpi.first.wpilibj.image.NIVision.MeasurementType;
import edu.wpi.first.wpilibj.image.NIVisionException;
import edu.wpi.first.wpilibj.image.ParticleAnalysisReport;
import org.usfirst.frc4579.FinalProject.RobotMap;

/**
 *
 */
public class Camera extends Subsystem {

    //Camera constants used for distance calculation
    //Y Image resolution in pixels, should be 120, 240, or 480
    final int Y_IMAGE_RES = 240;
    //Axis M1013 camera, from mfr.
    final double VIEW_ANGlE = 67;
    final double PI = Math.PI;
    //Score limits used for target identification.
    final int RECTANGULARITY_LIMIT = 40;
    final int ASPECT_RATIO_LIMIT = 55;
    //Score limits used for hot target determination
    final int TAPE_WIDTH_LIMIT = 50;
    final int VERTICAL_SCORE_LIMIT = 50;
    final int LR_SCORE_LIMIT = 50;
    //Minimum area of particles to be considered
    final int AREA_MINIMUM = 150;
    //Maximum number of particles to process
    final int MAX_PARTICLES = 8;
    //hotGoal determination.
    public boolean hotGoal = false;
    public boolean cameraInitialized = false;
    //the axis camera object (connected to the D-Link)
    AxisCamera camera;
    ColorImage image;
    //the criteria for doing the particle filter operation
    CriteriaCollection cc;
    //the image we get from the camera
    double rectLong, rectShort;
    Timer timer = new Timer();
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Relay light = RobotMap.cameraLight;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }

    public void cameraPreInit() {
        // get an instance of the camera
        System.out.println("....Delay 60 seconds for AxisCamera startup.");
        Timer.delay(60.0);
        camera = AxisCamera.getInstance("10.45.79.11");
    }

    public void cameraInit() {
        timer.start();
        int imageWidth = 0;
        //keep trying to get an image from the camera until we get one or
        //10 seconds has passed
        while ((imageWidth == 0) & (timer.get() < 10.0)) {
            try {
                image = camera.getImage();
                imageWidth = image.getWidth();
            } catch (NIVisionException error) {
                System.out.print(".");
            } catch (AxisCameraException error) {
                System.out.print(".");
            }
        }
        System.out.println("");
        if (imageWidth == 0) {
            System.out.println("......Camera did not initialize in 10 secs");
        } else {
            cameraInitialized = true;
            System.out.println("......Camera image in " + timer.get() + " secs.");
        }
    }

    public void SetCameraForOps() {
        camera.writeBrightness(50);
        camera.writeColorLevel(50);
        camera.writeWhiteBalance(AxisCamera.WhiteBalanceT.automatic);
    }

    public void ImageAnalysis() {
        System.out.println(".......Starting ImageAnalysis.");
        Timer timer = new Timer();
        int imageWidth = 0;
        int countV = 0;
        int countH = 0;
        hotGoal = false;
        double aspectRatio, area, areaRatio;

        timer.start();
        while ((imageWidth == 0) & (timer.get() < 2.0)) {
            try {
                image = camera.getImage();
                imageWidth = image.getWidth();
            } catch (NIVisionException error) {
            } catch (AxisCameraException error) {
            }
        }
        if (imageWidth == 0) {
            System.out.println(".......Camera did not get image in 2 secs!");
        } else {
            System.out.println(".......Image capture time: " + timer.get());
        }

        try {
            timer.reset();
            timer.start();
            cc.addCriteria(MeasurementType.IMAQ_MT_AREA, AREA_MINIMUM, 65535, false);
            double idealAspectRatioV = 8.0;
            double idealAspectRatioH = 5.875;
            image.write("C:/image.jpg");

            BinaryImage thresholdImage = image.thresholdHSV(0, 255, 0, 10, 240, 255);
            thresholdImage.write("C:/threshold.bmp");

            BinaryImage filteredImage = thresholdImage.particleFilter(cc);
            filteredImage.write("C:/filtered.bmp");

            int numParticles = filteredImage.getNumberParticles();
            System.out.println(".......NumParticles:" + numParticles);

            ParticleAnalysisReport report[] = filteredImage.getOrderedParticleAnalysisReports(MAX_PARTICLES);
            if (numParticles > 0) {
                for (int i = 0; i < Math.min(numParticles, MAX_PARTICLES);
                        i++) {
                    rectLong = NIVision.MeasureParticle(image.image, i, false, MeasurementType.IMAQ_MT_EQUIVALENT_RECT_LONG_SIDE);
                    rectShort = NIVision.MeasureParticle(image.image, i, false, MeasurementType.IMAQ_MT_EQUIVALENT_RECT_SHORT_SIDE);
                    aspectRatio = (double) report[i].boundingRectWidth
                            / (double) report[i].boundingRectHeight;
                    if (aspectRatio < 1.0) {
                        aspectRatio = 1.0 / aspectRatio;
                    }
                    area = report[i].particleArea;
                    areaRatio = area / ((double) report[i].boundingRectHeight * (double) report[i].boundingRectWidth);
                    double verticalQual = Math.abs(aspectRatio - idealAspectRatioV) / idealAspectRatioV;
                    double horizontalQual = Math.abs(aspectRatio - idealAspectRatioH) / idealAspectRatioH;
                    if ((areaRatio > .7) && (report[i].particleQuality > 98.0)) {
                        if (verticalQual <= .4) {
                            countV += 1;
                        }
                        if (horizontalQual <= .4) {
                            countH += 1;
                        }
                    }
                    System.out.println(".......Particle -- " + 1);
                    System.out.println("........ Height" + report[i].boundingRectHeight);
                    System.out.println("........ Width" + report[i].boundingRectWidth);
                    System.out.println("........ Area" + report[i].particleArea);
                    System.out.println("........ RectL" + rectLong);
                    System.out.println("........ RectS" + rectShort);

                    System.out.println("........ CoM-XY" + report[i].center_mass_x + ", " + report[i].center_mass_y);
                    System.out.println("........ Quality" + report[i].particleQuality);
                    System.out.println("........ V-Qual" + verticalQual);
                    System.out.println("........ H-Qual" + horizontalQual);
                    System.out.println("........cV, cH" + countV + ", " + countH);
                }
                if (countV >= 1 && countH >= 1) {
                    hotGoal = true;
                }
                System.out.println(".......Hot Goal is " + hotGoal);
            }

            filteredImage.free();
            thresholdImage.free();
            image.free();

            System.out.println(".......Time for ImageAnalysis: " + timer.get());
            timer.reset();
        } catch (NIVisionException ex) {
            System.out.println(".......NI-Vex: " + ex.getMessage());
        }
    }//end of ImageAnalysis function.

    public boolean getHotGoal() {
        return hotGoal;
    }

    public void lightToggle() {
        if (light.get() == Relay.Value.kOff) {
            light.set(Relay.Value.kForward);
            return;
        }
        if (light.get() == Relay.Value.kForward) {
            light.set(Relay.Value.kOff);
        }
    }

    public void lightOn() {
        light.set(Relay.Value.kForward);
    }

    public void lightOff() {
        light.set(Relay.Value.kOff);
    }
}
