// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc4579.FinalProject.subsystems;

import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.SpeedController;
import org.usfirst.frc4579.FinalProject.RobotMap;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc4579.FinalProject.Robot;
import org.usfirst.frc4579.FinalProject.commands.*;

/**
 *
 */
public class Elevator extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController height = RobotMap.tilterHeight;
    Encoder encoder = RobotMap.tilterEncoder;
    DigitalInput limit = RobotMap.tilterLimit;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    double speeds[] = {-0.3, 0.0, 0.0};  //change this to adjust the downward profile of the cam.
    int indexes = speeds.length;
    int index = 0;
    
    int highAngleUp = -40;
    int highAngleDn = -40;
    double upPowerMin = 0.55;
    double dnPowerMin = 0.20;
    double upPowerMax = 0.7;
    double dnPowerMax = 0.5;
    //Note: may also need to make max power a variable.
    double upSlope, dnSlope;

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new ToroHeight());
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }

    /*  Parameter Robot.tilterMethod provides two methods for moving the window motor.
     method = 0 uses a fixed speed to elevate, and a pulsed fixed speed to lower.
     method = 1 uses a speed calculated from the Encoder count, and uses more
     speed to generate more torque at the higher angles.  All of this is to 
     compensate for the nonlinear mechanical problems with the cam/tilt plate 
     system.
    
     Note:  a positive speed value raises the tilt plate, and decreases the
     encoder count.  The encoder count is initialized in the high tilt position, 
     and then counts down to -96 counts at the low angle position.
     */
    public void tilt(double speed) {
        SmartDashboard.getNumber("HighAngleUp", highAngleUp);
        SmartDashboard.getNumber("HighAngleDn", highAngleDn);
        SmartDashboard.getNumber("UpPowerMin", upPowerMin);
        SmartDashboard.getNumber("DnPowerMin", dnPowerMin);
        SmartDashboard.getNumber("UpPowerMax", upPowerMax);
        SmartDashboard.getNumber("DnPowerMaz", dnPowerMax);
        upSlope = +(upPowerMax - upPowerMin) / (-highAngleUp);
        dnSlope = -(dnPowerMax - dnPowerMin) / (-highAngleDn);
        SmartDashboard.putNumber("UpSlope", upSlope);
        SmartDashboard.putNumber("DnSlope", dnSlope);
        SmartDashboard.putNumber("Setpoint", Robot.setpoint);
        SmartDashboard.putNumber("Encoder", getEncoderCount());
        SmartDashboard.putNumber("Error", Robot.setpoint - getEncoderCount());

        if (speed == 0.0) {
            stop();
        }
        if (speed < 0.0 && getEncoderCount() < -96.0) {
            stop();
        }
        if (speed > 0.0 && (getEncoderCount() >= 0.0)) {
            stop();
            //encoderInit();
        }
        if (Robot.tilterMethod == 0) {
            if (speed < 0.0) {
                height.set(speeds[index]);
                index = (index + 1) % indexes;
            }
            if (speed > 0.0) {
                height.set(0.65);
            }
        }
        if (Robot.tilterMethod == 1) {
            if (speed < 0.0) {
                height.set(-(Math.max(dnPowerMin, dnPowerMax - dnSlope * getEncoderCount())));
            }
            if (speed > 0.0) {
                height.set(+(Math.max(upPowerMin, upPowerMax - upSlope * getEncoderCount())));
            }
        }
    }

    /*  The Encoder has 250 pulses per revolution.  The cRIO is set to count
     all the rising and falling edges of the A & B channels, so it counts
     four times the lines on the encoder, or 1000 pulses per revolution.
     The robot goes from 0 to 96 counts on the tilt plate, which is 24 lines
     on the encoder wheel, or 35 degrees of angle.
     */
    public void encoderInit() {
        encoder.reset();
        encoder.start();
        SmartDashboard.putNumber("Encoder", getEncoderCount());
    }

    /* Raw encoder count is 4x the normal count, so this gives us
    increased resolution.
    */
    public int getEncoderCount() {
        return encoder.getRaw();
    }

    public void angleUp() {
        height.set(0.3);
        SmartDashboard.putNumber("Encoder", getEncoderCount());
    }

    public void angleDown() {
        height.set(-.2);
        SmartDashboard.putNumber("Encoder", getEncoderCount());
    }

    public void stop() {
        height.set(0.0);
        SmartDashboard.putNumber("Encoder", getEncoderCount());
    }

    public void drop() {
        height.set(-.8);
    }

    public double getSpeed() {
        return height.get();
    }

    //will probably discard this switch.
    public boolean getLimit() {
        return !limit.get();
    }
}
